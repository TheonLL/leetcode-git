#  java 后端知识

[toc]

##  1 java 基础知识

###  1.java语言特点

1. 简单易学（语法简单、没有c++中的指针、增加了垃圾回收机制）；
2. 面向对象（继承、封装、多态）；

>1.什么是面向对象（oop），什么是面向过程、有什么区别？
>
>面向过程是具体化的、流程化的，就是一个动作的具体实现，将一个动作拆分成递进的若干个动作；
>
>面向对象是模型化的，就是把面向过程也就是方法的具体实现抽象成一个类，并封装；
>
>优点：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。
>缺点：不易维护、不易复用、不易扩展.
>
>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 .
>缺点：性能比面向过程差
>
>2.继承？
>
>一个对象获得另外一个对象的属性和方法，提高代码复用性；继承是多态的前提。
>
>3.封装？
>
>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。
>
>4.多态？
>
>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。多态的三个必要条件：继承、重写、父类引用指向子类。

3. 平台无关性（通过jvm实现平台无关性）；
4. 支持多线程；
5. 可靠性；
6. 支持网络编程并且方便；
7. 编译与解释并存；

>java源程序首先要经过一次编译形成字节码文件.class，此字节码文件不面向特定机器，而是面向JVM虚拟机的，具体面向机器的过程交由JVM来完成，不同的操作系统有着不同版本的JVM，这些JVM并不相同，但是他们都能够识别相同的.class字节码文件，将字节码文件翻译成特定机器的二进制码来执行。所以java 的跨平台性就是java源程序编译成的.class文件，在任何操作系统上通过该系统对应的JVM都能够顺利执行，java跨平台不等于JVM跨平台，JVM是非跨平台的！
>从java源程序到执行的过程可以看见，这个过程即有了编译步骤也有解释步骤。但是本质上来讲，编译的最终结果也只是.class文件，不是机器码，最终还是需要JVM来统一解释，所以更多的应该将java视为解释性语言。
>由于解释性语言性能比较低，后来java引入了JIT编译，某些被频繁执行的方法或者代码块，会被JVM认定为“热点代码”。在运行时JVM会把这些热点代码编译成与本地平台相关的机器码，并且进行各种层次的优化，以提高执行效率。

###  2.介绍一下jvm、jdk、jre

1. Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。
2. JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。
3. JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

### 3.java和c++的区别

1. java不提供指针直接访问内存，程序内存更加安全；
2. java类是单继承，C++支持多继承；虽然java的类不能单继承，但是接口可以多继承；
3. java有自动内存管理垃圾回收机制(GC),C++需要手动释放内存；
4. java可以通过jvm实现一次编译多次运行的跨平台特性，C++依赖特定的平台；
5. java只支持方法重载，C++同时支持方法的重载和操作符的重载

### 4.基本数据类型

byte、short、int、long、float、double、char、boolean八大基本数据类型；

6中数字类型、1中字符类型、1种布尔类型；

| 名称    | 字节 | 位数 | 默认值 | 范围 | 包装类型  | 包装类型默认值 |
| ------- | ---- | ---- | ------ | ---- | --------- | -------------- |
| byte    | 1    | 8    | 0      |      | Byte      | null           |
| short   | 2    | 16   | 0      |      | Short     | null           |
| int     | 4    | 32   | 0      |      | Integer   | null           |
| long    | 8    | 64   | 0L     |      | Long      | null           |
| float   | 4    | 32   | 0f     |      | Float     | null           |
| double  | 8    | 64   | 0d     |      | Double    | null           |
| char    | 2    | 16   | u0000  |      | Character | null           |
| boolean |      | 1    | false  |      | Boolean   | null           |



### 5.装箱、拆箱

装箱和拆箱是指的java语言中8大基本数据类型和对应的包装类型之间的转换，`装箱`是指的基本数据类型值变成包装类型的实例，通过包装类的valueof方法实现（Integer.valueof）;`拆箱`指的是包装类实例变成基本数据类型的值，通过i.intValue实现。

>1.除了（Double、Float）之外的数值类型装箱的时候为了`提升性能和节约内存`自动装箱过程会判断，如果数值在[-128,127]之间，就返回指向IntegerCache.cache中已经存在的对象引用，否则则重新创建一个对象；
>
>2.boolean类型自动装箱时 所有的True都是赋个一个静态值为true的Boolean对象，所有的False都是赋给一个静态值为false的Boolean对象；
>
>3.Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别；
>
>​	第一种方式不会触发自动装箱的过程；而第二种方式会触发；在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。
>
>4.当“==”运算符的两边都是包装类型的引用，则是比较指向的是否为同一个对象，如果其中有一个一边是数值或者运算式（a+b），则会进行自动拆箱；
>
>
>
>



### 6.字符类型和字符串类型常量的区别

1.形式上：字符常量式单引号引起的一个字符，字符串常量是双引号引起的若干个字符；

2.含义上：字符常量相当于一个整形值，可以参加表达式计算，字符串常量代表一个内存地址

3.内存占用：字符常量占两个字节，字符串常量占若干个字节。



### 7.String和StringBuffer、StringBuilder的区别是

1.可变性：String不可变、StringBuffer和StringBuilder是可变的；

2.线程安全性：String是线程安全的，StringBuffer对所有的公开方法都加了synchronized修饰，是线程安全的；StringBuilder是非线程安全的；

3.性能：StringBuilder>StringBuffer>String





### 8.Switch是否能作用在byte上，是否可以作用在long上，是否可以作用在String上

1.switch可以作用与char、byte、short、int以及他们的包装类型，jdk1.5之后可以作用与枚举类型，在jdk1.7之后可以作用于String类型

>不能作用于double、float、boolean及他们的包装类型；
>
>switch的转换和具体系统实现有关，如果分支比较少，可能会转换为跳转指令（条件跳转指令和无条件跳转指令）。但如果分支比较多，使用条件跳转会进行很多次的比较运算，效率比较低，可能会使用一种更为高效的方式，叫跳转表。跳转表是一个映射表，存储了可能的值以及要跳转到的地址，形如：
>
>| 值1  | 代码块1的地址 |
>| ---- | ------------- |
>| 值2  | 代码块2的地址 |
>| ...  |               |
>| 值n  | 代码块n的地址 |
>
>跳转表为什么会更为高效呢？因为，其中的值必须为整数，且按大小顺序排序。按大小排序的整数可以使用高效的二分查找，即先与中间的值比，如果小于中间的值则在开始和中间值之前找，否则在中间值和末尾值之间找，每找一次缩小一倍查找范围，其算法复杂度为O(log2n)。
>
>如果值是连续的，则跳转表还会进行特殊优化，优化为一个数组，连找都不用找了，值就是数组的下标索引，直接根据数组下标索引就可以找到跳转的地址。
>
>即使值不是连续的，但数字比较密集，差的不多，编译器也可能会优化为一个数组型的跳转表，没有的值指向default分支。
>
> 
>
>程序源代码中的case值排列不要求是排序的，编译器会自动排序。switch判断的类型可以是byte, short, int, char, 枚举和String（java7及之后支持）。其中byte/short/int/char本来就是整数，而枚举类型也有对应的整数序号ordinal，String用于switch时也会通过hashCode方法转换为整数，为什么不可以使用long呢？因为跳转表值的存储空间一般为32位，容纳不下long。
>
>需要说明下String的hashCode值可能冲突，而解决冲突的方式就是跳转之后再通过equals方法判定字符串内容是否相等。
>
>



### 9.访问修饰符

java语言中有四种权限访问控制符，这四种访问权限的控制符能够控制类中成员的可见性。其中类有两种，public、default，而方法和变量有4种，public、default、protected、private。

- public：对所有类可见。所有类型，类、接口、变量、方法；
- default：在同一包内可见。所有类型，类、接口、变量、方法；
- protected：对同一包内的类和所有子类可见。使用对象，变量、方法；
- private：在同一类中可见。使用对象，变量、方法。不能修饰外部类。



###  10.关键字

| 访问控制             | private  | protected  | public   |              |            |           |        |
| -------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |
| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |
|                      | new      | static     | strictfp | synchronized | transient  | volatile  |        |
| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |
|                      | for      | instanceof | switch   | case         | default    |           |        |
| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |
| 包相关               | import   | package    |          |              |            |           |        |
| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |
|                      | short    | null       | true     | false        |            |           |        |
| 变量引用             | super    | this       | void     |              |            |           |        |
| 保留字               | goto     | const      |          |              |            |           |        |

####  1.static

static 关键字就是为了`在没有创建对象实例的时候也就对变量或者方法的调用优化程序性能`

- static变量：可以直接通过类名来访问它；
- static方法：静态方法不依赖于任何对象就可以进行访问，在静态方法中不能访问非静态成员变量和非静态方法，因为非静态成员变量和方法都是必须依赖具体实例化对象才可以被调用，但是在非静态方法中可以访问静态变量和方法；
- static代码块：静态代码块主要用途是拿来优化程序性能，只会在类加载时被加载一次，很多时候将一些只需要执行一次的初始化操作放在static代码块中，如果程序中有多个代码块，在类初次被加载的时候，会按照static块的顺序来执行每个static块；
- 初始化顺序：静态变量和静态代码块优先于成员变量和普通代码块，静态变量和静态代码块的执行顺序取决于它们在代码中的先后位置。如果存在继承关系，`父类中的静态变量和静态代码块---》子类中的静态变量和静态代码块----》父类中的实例变量和普通代码块----》父类构造函数----》子类的实例变量和普通代码块----》子类的构造函数`；

#### 2.final关键字

final关键字主要用于修饰类，变量，方法

1. 类：被final修饰的类不能被继承；
2. 方法：被final修饰的方法不能被重写；
3. 变量：被final修饰的变量是基本类型，变量的数值不能改变；被修饰的变量是引用类型，变量不能在引用其他对象，但是变量引用的对象本身是可以改变的；

final、finally、finalize的区别；

- final主要用于修饰类、变量、方法；
- finally一般作用于try-catch代码块中，在处理异常时候，将一定要执行的代码方法放在finally代码块中；
- finalize是一个属于object类的方法，该方法一般由垃圾回收器来调用。

#### 3.this关键字

1. this关键字可以用来引用当前类的实例变量，
2. this关键字可用于调用当前类的方法；
3. this关键字可以用来调用当前类的构造函数；this要放在构造函数的第一行，不然编译会报错
4. ..

####  4.super关键字

1. super可以用来直接引用父类的实例变量；
2. super可以用来直接调用父类的构造函数；必须放在方法的第一行
3. super可以用来直接调用父类的方法；

#### 5.break、continue、return的区别

- break结束当前的循环体；
- continue结束本次循环，进入下一次循环；
- return 结束当前方法；

####  6.Atomic、volatile、synchronized、ThreadLocal关键字的区别







####  7.native关键字

当java中的方法用native来修饰的时候，就表示这个方法是一个本地方法。换言之，就是不是使用java语言实现的方法。例如hashCode





###  11.构造方法

构造方法是类的一种特殊方法，用来初始化类的一个新的对象，在创建对象（new 关键字）之后自动调用。java中的每个类都有一个默认的构造方法，并且可以有一个以上的构造方法。

Java 构造方法有以下特点：

- 方法名必须与类名相同
- 可以有 0 个、1 个或多个参数
- 没有任何返回值，包括 void
- 默认返回类型就是对象类型本身
- 只能与 new 运算符结合使用







###  12.重载和重写

方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

- 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
- 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。
- 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。

>1.重载：
>
>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。
>
>**重载规则:**
>
>- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
>- 被重载的方法可以改变返回类型；
>- 被重载的方法可以改变访问修饰符；
>- 被重载的方法可以声明新的或更广的检查异常；
>- 方法能够在同一个类中或者在一个子类中被重载。
>- 无法以返回值类型作为重载函数的区分标准。
>
>2.重写：
>
>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。
>
>**重写规则:**
>
>- 参数列表与被重写方法的参数列表必须完全相同。
>- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
>- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
>- 父类的成员方法只能被它的子类重写。
>- 声明为 final 的方法不能被重写。
>- 声明为 static 的方法不能被重写，但是能够被再次声明。
>- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
>- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
>- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
>- 构造方法不能被重写。
>- 如果不能继承一个类，则不能重写该类的方法。

| 区别点   | 重载方法 | 重写方法                                       |
| :------- | :------- | :--------------------------------------------- |
| 参数列表 | 必须修改 | 一定不能修改                                   |
| 返回类型 | 可以修改 | 一定不能修改，可以小于父类得返回类型           |
| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |

###  13.==和equals的区别

对于基本数据类型来说，==比较的是值；对于引用类型数据来说， ==比较的对象的内存地址；

equal方法不能作用于判断基本数据类型，equals方法存在于object类中，object方法是所有类的直接或间接父类

- **类没有覆盖 `equals()`方法** ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。
- **类覆盖了 `equals()`方法** ：一般我们都覆盖 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

###  14.hashCode()与equals()

hashCode 的作用是获取哈希码，也称散列码；实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是： `Object` 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。

**3)为什么重写 `equals` 时必须重写 `hashCode` 方法？**

如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**





###  15.浅拷贝、深拷贝的区别

给新变量复制的时候

- 浅拷贝：对基本数据类型进行值传递，对引用数据类型复制一个引用指向原始引用的对象，就是复制的引用和原始引用指向同一个对象；
- 深拷贝：对基本数据类型进行值传递，对引用数据类型创建一个新的对象，并复制其内容，两个引用指向两个对象，但是内容相同；

通过重写clone类或者序列化来实现。



###  16.序列化

-  序列化：将对象转化为字节序列
- 反序列化：将字节序列转化为对象
- 序列化的意义：将java对象转化成为字节序列，方便通过网络传输或者存储在磁盘上，在需要的时候可以通过反序列化恢复；
- 实现方式：1.实现Serializable接口，2.实现Externalizable接口；
- 序列化注意事项：
  - 对象的类名、实例变量会被序列化，方法、类变量、transient实列变量都不会被序列化；
  - 可以同通过transient修饰，使得变量不被序列化；
  - 序列化对象的引用类型成员变量，也必须是可以序列化的，否则会报错；
  - 反序列化时必须有序列化对象的class文件；



###  17.泛型

- 泛型意味着编写的代码可以被不同类型的对象所重用，本质上是参数化类型，也就是说操作的数据类型被指定为一个参数；
- 通配符：传入一个类型的指定范围；
  - <?>无限制通配符，表示可以持有任何类型；
  - <? extends E>上界通配符，表示这个泛型中的参数必须是E或者E的子类：用于灵活的读取
  - <? super E> 下界通配符，表示这个泛型的参数必须是E或者E的父类，用于灵活的写入或者比较
- 当编译器对带有泛型的java代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这个普通的字节码可以被一般的java虚拟机接收并执行，这就叫做类型的擦除；
  - Java 编辑器会将泛型代码中的类型完全擦除，使其变成原始类型。当然，这时的代码类型和我们想要的还有距离，接着 Java 编译器会在这些代码中加入类型转换，将原始类型转换成想要的类型。这些操作都是编译器后台进行，可以保证类型安全。总之泛型就是一个语法糖，它运行时没有存储任何类型信息。
- 优点：
  - 类型安全，编译时期就可以检查出类型是否正确；
  - 消除强制类型转换；
  - 潜在的性能收益。

###  18.反射

- 反射：就是获取任意一个类的所有属性和方法，你还可以调用这些属性和方法；
- 反射机制的优缺点：
  - 优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利；
  - 缺点：让我们在运行时有了分析操作类的额能力，这同时也增加了安全问题。
- 反射的应用场景：java的注解的实现就用到了反射，动态代理也依赖反射实现，springboot、mybatis等各种框架中有用到。@component、@value注解用到；

###  19.代理模式

1. 代理模式：为一个目标对象提供一个代理，通过控制这个代理来访问目标对象；

2. 代理模式优点：

   1. 可以在目标对象实现的基础上，增加额外的操作功能；
   2. 屏蔽对目标对象的直接访问，使得目标对象更加安全；
   3. 降低系统耦合度；

3. 代理模式缺点：

   1. 创建了多余的开销
   2. 系统更加复杂

4. 代理模式的分类：

   1. 静态代理：静态定义代理类；
   2. 动态代理
      - jdk自带的动态代理；
      - CGLIB代理；
      - javaassist字节码操作库实现

5. 应用场景：

   1. 安全代理
   2. 远程代理
   3. 延迟加载
   4. 常见的框架中基本上都用到了代理模式

6. 静态代理模式：

   1. 定义一个目标对象的接口：
   2. 通过实现目标对象接口来创建目标对象，通过实现目标对象接口生成代理对象；
   3. 实例化代理对象时，将目标对象传给代理对象；
   4. 优点：在不修改目标对象的功能前提下，能通过代理对象目标功能扩展；
   5. 缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类。一旦接口增加方法,目标对象与代理对象都要维护

7. 动态代理jdk实现：

   1. 定义一个目标对象的接口
   2. 实现目标对象接口来创建目标对象，代理对象则通过jdk中的API，动态的在内存中构建；
   3. java.lang.reflect.Proxy
      • 作用：动态生成代理类和对象
      java.lang.reflect.InvocationHandler(处理器接口)
      • 可以通过invoke方法实现对真实角色的代理访问。
      • 每次通过Proxy生成代理类对象对象时都要指定对应的处理器对象
   4. 优点：抽象角色中(接口)声明的所以方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。
   5. 缺点：静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是 Cglib 代理

8. 动态代理cglib实现：

   1. Cglib 代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展。

9. [参考](https://blog.csdn.net/qq_42937522/article/details/105067563)

   []: 

###  20.异常

1. 程序运行出错就是异常
2. 异常分类：异常主要分为error和exception类
   1. error：error类以及他的子类的实例，代表了jvm本身的错误。错误不能被程序员通过代理处理；
   2. exception：exception类以及他的子类，代表程序运行时发送的各种不期望发生的事件，可以被java异常处理机制使用，时异常处理的核心；

![image-20210806171237737](java 后端知识.assets/image-20210806171237737.png)

3. 异常捕获：

   1. 除了errror类及其子类，RuntimeException类及其子类，其他的异常都需要强制捕获或者用throws声明；

   2. 用try...catch捕获异常；

      ```java
      public static void main(String[] args) {
          try {
              process1();
              process2();
              process3();
          } catch (UnsupportedEncodingException e) {
              System.out.println("Bad encoding");
          } catch (IOException e) {
              System.out.println("IO error");
          } finally {
              System.out.println("END");
          }
      }
      ```

      注意`finally`有几个特点：

      1. `finally`语句不是必须的，可写可不写；
      2. `finally`总是最后执行。不管有没有异常发生都会执行，

      当处理需要关闭的资源时，优先考虑用try-with-resources，而不是try-finally。这样得到的代码将更简洁，清晰，产生的异常也更有价值，这些也是try-finally无法做到的

