#  算法笔记

## 1 动态规划类型问题解决方法

###  1.1 问题特点 

带有递归特性，可以将问题拆分成子问题；一般具有**最优子结构**、**重复子问题**；

###  1.2 问题解法

**第一步**要明确两点，【状态】和【选择】。

先说状态，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？**所以状态有两个，就是「背包的容量」和「可选择的物品」**。

再说选择，也很容易想到啊，对于每件物品，你能选择什么？**选择就是「装进背包」或者「不装进背包」嘛**。

明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：

```shell
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

**第二步**要明确`dp`数组的定义。

`dp`数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用`dp`数组把状态表示出来。

最终框架：

```shell
int dp[N+1][W+1]
# 初始化开始位置
dp[0][..] = 
dp[..][0] = 

for i in [1..N]:
    for w in [1..W]:
    if 判断背包容量：
    	不够：
    		不把物品 i 装进背包--->奖励
    	够：
            dp[i][w] = max(
                把物品 i 装进背包--->奖励,
                不把物品 i 装进背包--->奖励
            ) 最值
            /是否可行：
             dp[i][w] = dp[i-1][w-wigth[i]]||dp[i-1][w]
             /多少种组合
             dp[i][w] = dp[i-1][w-wigth[i]]+dp[i-1][w]
return dp[N][W]
```

首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维`dp`数组，一维表示可选择的物品，一维表示背包的容量。



1. **暴力**解法步骤:所有的算法的基本思路，速度最慢

   1. 确定**状态**：原问题和子问题中变化的变量；例如coins问题中，由于硬币数量⽆
      限，所以唯⼀的状态就是⽬标⾦额 amount。
   2. 确定**dp函数**的定义：例如coins问题中、当前的目标金额是n，至少需要dp(n)个硬币凑出该金额。
   3. 然后确定**选择**并**择优**：也就是对于每个状态，可以做出什么选择改变当前状态；例如coins问题中，⽆论当的⽬标⾦额是多少，选择就是从⾯额列表coins 中选择⼀个硬币，然后**⽬标⾦额就会减少，硬币数量增加**。
   4. 最后明确 **base case**：明确特例，例如coins问题中，显然⽬标⾦额为 0 时，所需硬币数量为 0；当⽬标⾦额
      ⼩于 0 时，⽆解，返回 -1。

2. 带**备忘录**的解法：对于具有**重复子问题**的问题可以，通过创建备忘录(字典、hashMap)来记录，自顶向下的记录，速度一般

   public int solution(list ,n)

   ​	1.判断输入**参数**的**合法性**;

   ​	2.创建备忘录memo,大小一般为n+1,最多可能的情况；

   ​	3.定义dp函数dp(n)

   ​		4.查看所求方法(n对应的值)是不是在备忘录中

   ​		5.对base case进行判断

   ​		6.创建结果result并初始化

   ​		7.遍历所有选择

   ​			8.定义并赋值**子问题结果**(一般是**经历选择之后，新状态输入dp之后的值，即迭代值**)

   ​			9.终止判断，终止则使用continue跳出选择遍历循环

   ​			10.根据题目在**result初始值**和**子问题结果在本问题的更新值**中**择优**并赋值给result

   ​		11.将result存到备忘录memo中

   ​		12.返回meno[n]

   ​	13.返回结果dp(n)

   

3. **dp数组**解法：对具有**重复子问题**的问题可以，自底向上的方式创建一个dp数组(一般为数组int[])记录结果；速度最快

   public int solution(list ,n):

   ​	1.判断输入**参数**的**合法性**，可以插入base case;

   ​	2.**创建dp数组dpArr**，大小一般为n+1，最多种解

   ​	3.对dpArr进行初始化，一般用 Arrays.fill(int[]，startIndex，endIndex，fillVuale）,初始化的时候可以将base case放入dpArr中

   ​	4.遍历数组，i：

   ​		5.遍历所有选择，选择k：

   ​			6.判断是否满足终止条件，如果满足使用continue跳出遍历选择

   ​			7.根据题目目标在**dpArr[i]**和**dpArr[选择k之下的状态]的更新值**，择优并赋值给**dpArr[i]**

   ​	8.判断**dpArr[n]**并返回（判断**dpArr[n]**是否为初始值，是则-1，否则return **dpArr[n]**)

   

###  1.3   coins问题的java代码例子

```java
package dynanucProgramming;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;



public class MinCoins {
	public static void main(String[] args) {
		System.out.println("请输入amount：");
		Scanner scanner=new Scanner(System.in);
		int amount=scanner.nextInt();
		int[] coinsList=new int[] {1,5,10,20,50,100};
		CoinChange coinChange=new CoinChange(coinsList, amount);
		long time1=System.currentTimeMillis();
		System.out.println(coinChange.minCoinMemo(amount));
//		System.out.println(coinChange.minCoinsEnum(amount));
//		System.out.println(coinChange.minCoinDpAarr(coinsList,amount));
		long time2=System.currentTimeMillis();
		System.out.printf("算法花费了%d毫秒",(time2-time1));		
	}
}

class CoinChange{
	int[] coinsList;
	int amount;
	Map<Integer, Integer> memohashMap=new HashMap<>();
    
    
	/*
	 * 1 暴力穷举法 求解动态规划  速度最慢
	 */
	//
	public int minCoinsEnum(int amount) {
		//每次寻优都先初始化
		double coinsNum=Double.POSITIVE_INFINITY;
		//base case
		if (amount<0) {
			return -1;
		}else if (amount==0) {
			return 0;
		//正常情况
		}else {
			for(int coins :coinsList) {
				int subProblem=minCoinsEnum(amount-coins);
				//迭代终止条件
				if (subProblem==-1) {
					continue;
				// 选择硬币最少的组合
				}else {
					coinsNum=Math.min(coinsNum, subProblem+1);	
				}
			}
			//对值进行判断 并返回
			if (coinsNum!=Double.POSITIVE_INFINITY) {
				return (int) coinsNum;
			}else {
				return -1;
			}			
		}
	}
    
    
    
	/*
	 * 2 带备忘录的 自顶向下 速度一般   6000以下可以超过之后就会报错
	 */
	public int minCoinMemo(int amount) {

		if (memohashMap.containsKey(amount)) {
			return memohashMap.get(amount);
		}else {
			int coinNum=amount+1;
			if (amount<0) {
				return -1;
			}else if (amount==0) {
				return 0;
			}else {				
				for(int coins:coinsList) {
					int subProblem=minCoinMemo(amount-coins);
					// 迭代终止条件
					if (subProblem==-1) {
						continue;
					}else {
						coinNum=Math.min(coinNum, subProblem+1);
					}					
				}				
			}
			memohashMap.put(amount, (coinNum!=amount+1)? coinNum:-1);
			if (coinNum!=amount+1) {
				return coinNum;
			}else {
				return -1;
			}
			
		}
		
	}
	
	
	
	/*
	 * 3 dp数组 自底向上  速度最快
	 */
	public int minCoinDpAarr(int[] coinsList,int amount ) {
		if(coinsList.length==0) return -1;
		if (amount<0) return -1;
		int[] dparr=new int[amount+1];
		dparr[0]=0;
		Arrays.fill(dparr, 1, dparr.length, Integer.MAX_VALUE);
		for (int i = 0; i < dparr.length; ++i) {
			for(int coin :coinsList) {
				if (i-coin<0) continue;
				dparr[i]=Math.min(dparr[i], dparr[i-coin]+1);
			}
			}
		return (dparr[amount]==Integer.MAX_VALUE)? -1:dparr[amount];
			
		
	}
	
	// 构造方法
	public  CoinChange(int[] coinsList,int amount) {
		this.amount=amount;
		this.coinsList=coinsList;

	}
}
```



### 1.4 经典动态规划问题

1. 0-1背包问题

   

##  2 回溯法类型问题与解法













## 3 数组分割问题

将一个数组分割成两个部分，使得这两个部分和之差最小/相等，这种问题可以化为0-1背包问题，

特征：

- 元素不可分割



